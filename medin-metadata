#!/usr/bin/env python2

# ensure we're using UTF-8
import sys
sys = reload(sys)
sys.setdefaultencoding('utf-8')

DEBUG = False                           # controls debugging output

# replace the default warning display function with our own
import warnings
from warnings import showwarning as defaultwarning
def showwarning(*args, **kwargs):
    """
    Replacement for default warnings.showwarning

    This function only shows warnings when in debugging mode
    """
    global DEBUG
    if DEBUG: defaultwarning(*args, **kwargs)
warnings.showwarning = showwarning

def warn(msg):
    """Output a message to standard error"""

    sys.stderr.write("%s\n" % msg)
    try:
        log(msg)
    except NameError:
        pass                    # for when the medin module can't be imported
    
def die(msg):
    """End the program with a message"""

    warn(msg)
    sys.exit(1)
    
class Output(object):
    """
    Abstract base class for outputting metadata as XML
    """

    def __init__(self, validate=False):
        self.validate = validate

    def processMetadata(self, metadata):
        """
        Process an individual metadata instance
        """
        from cStringIO import StringIO
        import libxml2
        from medin import log
        from medin.metadata import XMLBuilder
        from medin.validate import validate, ValidationError

        # transform the metadata to XML
        builder = XMLBuilder(metadata)
        doc = builder.build()

        # try and validate the xml
        if self.validate:
            log('Performing validation')
            try:
                validate(doc)
            except ValidationError, e:
                warn('The document is not valid: %s' % e.args[0])
                return None
            else:
                log("The document is valid")

        # output the document
        f = StringIO()
        buf = libxml2.createOutputBuffer(f, 'utf-8')
        doc.saveFormatFileTo(buf, 'utf-8', True)
        doc.freeDoc()                       # clean up

        return f.getvalue().strip()

    def write(self, iter_metadata):
        raise NotImplementedError('This method must be overridden')

class FileOutput(Output):
    """
    Output metadata as XML to a file handle
    """

    def __init__(self, file, *args, **kwargs):
        self.fh = file

        super(FileOutput, self).__init__(*args, **kwargs)

    def write(self, iter_metadata):
        for metadata in iter_metadata:
            xml = self.processMetadata(metadata)
            if not xml:
                continue
            self.fh.write(xml)
            self.fh.write("\n")

class MIMEOutput(FileOutput):
    """
    Output metadata as XML wrapped in MIME format
    """

    def __init__(self, *args, **kwargs):
        from uuid import uuid4
        self.uid = uuid4().hex  # get an unique identifer

        super(MIMEOutput, self).__init__(*args, **kwargs)

    def write(self, iter_metadata):
        from medin import __version__
        self.fh.write("""MIME-Version: 1.0
Content-Type: multipart/mixed; charset=UTF-8; boundary="%s"

MEDIN XML Metadata created by MEDIN Metadata Generator version %s\n""" % (self.uid, str(__version__)))

        for metadata in iter_metadata:
            xml = self.processMetadata(metadata)
            if not xml:
                continue
            filename = metadata.unique_id.id + '.xml'
            self.fh.write("""--%s
Content-Type: text/xml; charset=UTF-8;
Content-Disposition: inline; filename="%s";

""" % (self.uid, filename))
            self.fh.write(xml)
            self.fh.write("\n")

        self.fh.write("--%s--\n" % self.uid)  # the final boundary

class DirOutput(Output):
    """
    Output metadata as XML to a directory
    """

    def __init__(self, directory=None, *args, **kwargs):
        super(DirOutput, self).__init__(*args, **kwargs)

        from os.path import curdir, abspath
        if not directory:
            directory = curdir
        self.directory = abspath(directory)

    def write(self, iter_metadata):
        from os.path import join
        for metadata in iter_metadata:
            xml = self.processMetadata(metadata)
            if not xml:
                continue
            filename = metadata.unique_id.id + '.xml'
            path = join(self.directory, filename)
            try:
                fh = open(path, 'w')
                fh.write(xml)
            except IOError, e:
                die('Could not write metadata to file: %s: %s' % (e.strerror, e.filename))
            else:
                fh.close()

def main():
    """
    The main program
    """

    from optparse import OptionParser

    # try and load the medin modules
    try:
        import medin
        from medin import log, __version__
        from medin.util import check_environment
        import medin.schema
    except ImportError:
        die('The medin module could not be found. Please ensure it is in your python module search path.')
    
    # parse out the command options
    usage = """usage: %prog [OPTION]... [SCHEMA] [CONNSTRING]

  Extract metadata from a data provider database as MEDIN XML.

  SCHEMA is the name of the database schema in use by the provider
  database e.g. 'medin'.

  CONNSTRING is the connection parameter string for accessing the
  database. It should be in the following format:

  dialect://user:password@host/dbname

  where dialect is the name of the database system e.g

  oracle://me:mypass@myhost/mydb

  details of supported dialects are available at:
  http://www.sqlalchemy.org/docs/core/engines.html#supported-dbapis

  The CONNSTRING 'example' is a special argument that connects to a
  bundled sqlite database. This is a reference implementation of the
  medin schema based on the BODC EDMED oracle database. It can be
  called as follows:

  %prog medin example"""

    parser = OptionParser(usage=usage, version="%%prog %s" % str(__version__))

    # add the command line options
    parser.add_option("-l", '--list-schemas', action="store_true",
                      help="List the available schemas and exit")
    parser.add_option("-u", '--update-vocabs', action="store_true",
                      help="Update the locally stored vocabularies from the internet")
    parser.add_option("-c", '--update-contacts', action="store_true",
                      help="Update the locally stored contacts from the internet")
    parser.add_option("-d", '--debug', action="store_true",
                      help="Enable debugging output")
    parser.add_option("-i", '--metadata-id', action="append",
                      help="Output a specific resource ID. The ID must be the fully qualified unique resource identifier (Element 6 e.g. http://www.bodc.ac.uk/EDMED587). This option can be specified multiple times.")
    parser.add_option("-n", '--no-mime', action="store_true",
                      help="Do not encapsulate the XML output in MIME format. This is only useful when --destination is not specified.")
    parser.add_option("-o", '--destination',
                      help="Output the XML to the specified DIRECTORY. Existing files are over-written.")
    parser.add_option("-v", '--validate', action="store_true",
                      help="""Enable validation of output XML. A three step validation is performed:
1. Validate against the ISO TC 211 schema.
2. Validate against the ISO TS 19139 A1 Constraints.
3. Validate against the Medin Metadata Profile.
Any XML document passing these tests complies with the Medin Metadata
requirements.""")

    (options, args) = parser.parse_args()
    try:
        schema_name, connstr = args
    except ValueError:
        if not options.update_vocabs and not options.list_schemas and not options.update_contacts:
            parser.error("incorrect number of arguments")
        schema_name = connstr = None

    # turn on debugging
    global DEBUG
    if options.debug:
        DEBUG = medin.DEBUG = True

    try:
        check_environment()
    except EnvironmentError, e:
        die(str(e))

    # list the available schemas
    if options.list_schemas:
        from glob import glob1
        from os.path import splitext, dirname
        schemas = [f for f in [splitext(f)[0] for f in glob1(dirname(medin.schema.__file__), '*.py')] if f != '__init__']
        if not schemas:
            print "No schemas could be found!"
        else:
            print "Available schemas:"
            for schema in schemas:
                print '  '+schema
        return

    # start vocabulary and contact sessions
    import medin.vocabulary
    import medin.contact
    vocabs = medin.vocabulary.Session()
    contacts = medin.contact.Session()

    # update the vocabularies
    if options.update_vocabs:
        log("Setting up vocabularies")
        vocabs.create()    # clear and create the schema and hard-coded data
        log("Updating vocabularies from online sources")
        vocabs.update()    # update the online vocabs

    # update the contacts
    if options.update_contacts:
        log("Setting up contacts")
        contacts.create()    # clear and create the schema
        log("Updating contacts from online sources")
        contacts.update()    # update the online contacts

    if not schema_name:
        # the user only asked for vocabs and/or contacts to be updated
        return

    # create the database engine
    from sqlalchemy import create_engine
    from sqlalchemy.exc import ArgumentError
    engine = None
    if connstr == 'example':
        from os.path import join, dirname, abspath
        
        dbname = abspath(join(dirname(medin.__file__),'data','example.sqlite'))
        connstr = 'sqlite:///'+dbname

    try:
        engine = create_engine(connstr, echo=medin.DEBUG)
    except ArgumentError, e:
        die('Bad CONNSTRING: %s' % str(e))
    except ImportError, e:
        die('The database driver could not be found for the connection \'%s\': %s' % (connstr, e))

    # try and load the schema plugin
    log('Attempting to load schema %s' % schema_name)
    import imp
    try:
        schema_module = imp.load_module(schema_name, *imp.find_module(schema_name, medin.schema.__path__))
    except ImportError:
        die('The schema is not supported: %s' % schema_name)

    # retrieve the metadata
    provider = schema_module.Session(engine, vocabs, contacts)
    if options.metadata_id:
        ids = set(options.metadata_id)

        def metadata_generator():
            for metadata_id in ids:
                # get a specific metadata id
                log('Getting metadata id %s' % metadata_id)
                metadata = provider.getMetadataById(metadata_id)
                if not metadata:
                    die('A metadata entry with the following id does not exist: %s' % metadata_id)
                yield metadata
    else:
        log('Retrieving all metadata entries')

        def metadata_generator():
            for metadata in provider:
                yield metadata

    # output the metadata entries
    if options.destination:
        output = DirOutput(options.destination, options.validate)
    elif options.no_mime:
        output = FileOutput(sys.stdout, options.validate)
    else:
        output = MIMEOutput(sys.stdout, options.validate)

    from sqlalchemy.exc import DatabaseError
    try:
        output.write(metadata_generator())
    except DatabaseError, e:
        die('Database error: %s' % e.message)

if __name__ == '__main__':
    try:
        main()
    except IOError, e:
        if e.errno == 32:
            pass                # it's a broken pipe
        else:
            raise
    except KeyboardInterrupt:
        die("\nProgram interrupted! Exiting...")
    except Exception, e: 
        if DEBUG:
            raise
        else:
            die('FATAL ERROR: %s' % e)
