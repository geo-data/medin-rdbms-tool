#!/usr/bin/env python2

# Created by Homme Zwaagstra
# 
# Copyright (c) 2011 GeoData Institute
# http://www.geodata.soton.ac.uk
# geodata@soton.ac.uk
# 
# Unless explicitly acquired and licensed from Licensor under another
# license, the contents of this file are subject to the Reciprocal
# Public License ("RPL") Version 1.5, or subsequent versions as
# allowed by the RPL, and You may not copy or use this file in either
# source code or executable form, except in compliance with the terms
# and conditions of the RPL.
# 
# All software distributed under the RPL is provided strictly on an
# "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR
# IMPLIED, AND LICENSOR HEREBY DISCLAIMS ALL SUCH WARRANTIES,
# INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT, OR
# NON-INFRINGEMENT. See the RPL for specific language governing rights
# and limitations under the RPL.
# 
# You can obtain a full copy of the RPL from
# http://opensource.org/licenses/rpl1.5.txt or geodata@soton.ac.uk

# ensure we're using UTF-8
import sys
sys = reload(sys)
sys.setdefaultencoding('utf-8')

import logging
logging.captureWarnings(True)   # convert warnings into loggable events

class Filter(logging.Filter):
    def __init__(self, logger, *args, **kwargs):
        self.logger = logger
        super(Filter, self).__init__(*args, **kwargs)

    def filter(self, record):
        if record.exc_info and logger.getEffectiveLevel() > logging.DEBUG:
            # don't allow logs with exceptions (i.e. from
            # logging.exception()) unless we are DEBUGging
            return False
        return super(Filter, self).filter(record)

logger = logging.getLogger('main')
logger.addFilter(Filter(logger))

def die(msg):
    """End the program with a message to standard error"""

    sys.stderr.write("%s\n" % msg)
    sys.exit(1)

def output_metadata(options, provider):
    """
    Output metadata according to command line switches
    """
    from medin.output import MIMEOutput, FileOutput, DirOutput, ValidationWarning    

    # determine the output format
    validate = options.validation != 'none'
    embed_validation = not options.disable_embed_validation
    if options.destination:
        output = DirOutput(options.destination, validate, embed_validation)
    elif options.no_mime:
        output = FileOutput(sys.stdout, validate, embed_validation)
    else:
        output = MIMEOutput(sys.stdout, validate, embed_validation)

    # output the metadata entries with appropriate validation messages
    with output:
        for flush, warning in output(provider()):
            try:
                flush()              # output this metadata record
            except IOError, e:
                if e.filename:
                    msg = '%s: %s' % (e.strerror, e.filename)
                else:
                    msg = e.strerror
                logger.exception(e)
                die(msg)

            # deal with validation warnings
            if warning and validate:
                if options.validation == 'strict':
                    die('The metadata failed to validate.')

def main():
    """
    The main program
    """

    from argparse import ArgumentParser, RawDescriptionHelpFormatter, ArgumentError, FileType

    # try and load the medin modules
    try:
        import medin
        from medin import __version__
        from medin.util import check_environment
        import medin.source
    except ImportError:
        die('The medin module could not be found. Please ensure it is in your python module search path.')
    
    # parse out the command options
    description = """  Extract metadata from a metadata source and output it as MEDIN XML.

basic usage:
  The program is called with an action (listed below). All actions
  have specific options associated with them. These can be found by
  using the `--help` option after the action of interest e.g.

  %(prog)s output --help

  The most common action is `output`: this is used to generate MEDIN
  XML from a data source.
  
  There are a number of global options (also listed below) which can
  be applied before specifying the action.
"""
    parser = ArgumentParser(
        description=description,
        formatter_class=RawDescriptionHelpFormatter
        )

    # add the global command line options
    parser.add_argument('--version', action='version', version='%%(prog)s %s' % str(__version__))

    # groups the options used for logging
    log_group = parser.add_argument_group('logging', 'Options affecting the how the program logs its actions.')
    log_levels = [logging.getLevelName(l).lower() for l in (logging.CRITICAL, logging.ERROR, logging.WARNING, logging.INFO, logging.DEBUG)]
    log_group.add_argument('--log-level', default='warning', choices=log_levels,
                           help="Determine the verbosity of the application, defaulting to 'warning'.")
    log_group.add_argument('--log-output', metavar='FILE', type=FileType('w'), default=sys.stderr,
                           help="Save the logging output to a file. The default logs to standard error.")

    # Create the action subparsers
    action_parsers = parser.add_subparsers(
        title='actions',
        description='available tool actions, the most common being `output`.',
        help='Select an action for the tool to perform. Specify `--help` after the action in order to detail the specific options available for that action.')

    def do_update(args, vocabs, contacts):
        """
        Perform the `update` action
        """
        # set the same logging level for the SQLAlchemy package as
        # that used for the rest of the application:
        logging.getLogger('sqlalchemy').setLevel(logger.getEffectiveLevel())

        # update the vocabularies
        if not args.exclude_vocabs:
            logger.info("Updating vocabularies from online sources")
            vocabs.update()    # update the online vocabs
        else:
            logger.info('Skipping vocabulary update')

        # update the contacts
        if not args.exclude_contacts:
            logger.info("Setting up contacts")
            contacts.create()    # clear and create the schema
            logger.info("Updating contacts from online sources")
            contacts.update()    # update the online contacts
        else:
            logger.info('Skipping contact update')

    update_parser = action_parsers.add_parser(
        'update',
        description="""  Update the tool's internal data caches (requires online access). 

  The caches contain local data for MEDIN vocabulary and EDMO contact
  databases. Updating a database will replace the previous data with
  the latest data available from the internet.  Once updated, the new
  data will be available to subsequent invocations of the program.

basic usage:
  %(prog)s
""",
        formatter_class=RawDescriptionHelpFormatter)

    update_parser.add_argument('--exclude-vocabs', action="store_true",
                               help="Do not update the locally stored vocabularies database")
    update_parser.add_argument('--exclude-contacts', action="store_true",
                               help="Do not update the locally stored contacts database")
    update_parser.set_defaults(action=do_update)

    def do_output(args, vocabs, contacts):
        """
        Perform the `output` action
        """
        provider = args.output(args, vocabs, contacts)
        output_metadata(args, provider)

    output_parser = action_parsers.add_parser(
        'output',
        description="""  Retrieve metadata from a data source and output it as MEDIN XML.

basic usage:
  Follow `output` by specifying with one of the available metadata
  sources (listed below).  Metadata will be extracted from the source
  and output as MEDIN XML.  Each metadata source has its own specific
  command line arguments which can be listed by using the `--help`
  option after the data source of interest e.g.

  %(prog)s medin-rdbms --help
""",
        epilog="""validation:
  Passing 'warn' or 'strict' to the program using the --validation
  option will validate the XML before it is output. A three step
  validation is performed:

  1. Validate against the ISO TC 211 W3C schema.
  2. Validate against the ISO TS 19139 A1 Constraints (version 1.3)
  3. Validate against the Medin Metadata Profile (version 1.7)

  Any XML document passing these tests complies with the Medin
  Metadata requirements.""",
        formatter_class=RawDescriptionHelpFormatter)

    output_parser.add_argument(
        "-n", '--no-mime', action="store_true",
        help="Do not encapsulate the XML output in MIME format. This is only useful when --destination is not specified.")
    output_parser.add_argument(
        "-o", '--destination', metavar='DIRECTORY',
        help="Output the XML to the specified DIRECTORY. Existing files are over-written.")
    output_parser.add_argument(
        "-v", '--validation', default='strict', metavar='LEVEL',
        choices=['none', 'warn', 'strict'],
        help="""Control validation of output XML. LEVEL can be one of: 'none' - disable validation; 'warn' - output warning messages for failed validations; 'strict' (default) - output a warning message for a failed validation and exit the program""")
    output_parser.add_argument(
        "-e", '--disable-embed-validation', action="store_true",
        help="By default the validation status of a document is embedded in an XML comment at the top of the document. This option prevents this."
        )
    output_parser.set_defaults(action=do_output)

    # Load the available source subparsers
    source_parsers = output_parser.add_subparsers(
        title='sources',
        description='available sources of metadata.',
        help='Select a metadata source with the appropriate command line arguments in order to output the metadata. Specify `--help` after the source in order to detail the source specific options available.')
    from glob import glob1
    from os.path import splitext
    import imp
    schemas = [f for f in [splitext(f)[0] for f in glob1(medin.source.__path__[0], '*.py')] if f != '__init__']
    for schema_name in schemas:
        schema_module = imp.load_module(schema_name, *imp.find_module(schema_name, medin.source.__path__))
        schema_module.set_argument_subparser(source_parsers)

    options = parser.parse_args()

    # set the log level
    log_level = getattr(logging, options.log_level.upper())
    logging.basicConfig(level=log_level, stream=options.log_output)
    logger.debug('Processed by Python %s' % sys.version)
    logger.debug('Invoked as: %s' % ' '.join(sys.argv))

    try:
        check_environment()
    except EnvironmentError, e:
        logger.exception(e)
        die(str(e))

    if not options.action:
        return

    # start vocabulary and contact sessions
    import medin.vocabulary
    import medin.contact
    vocabs = medin.vocabulary.Session()
    contacts = medin.contact.Session()

    # execute the action
    try:
        options.action(options, vocabs, contacts)
    except (ArgumentError, RuntimeError), e:
        logger.exception(e)
        die(str(e))

if __name__ == '__main__':
    try:
        main()
    except IOError, e:
        if e.errno == 32:
            pass                # it's a broken pipe
        else:
            raise
    except KeyboardInterrupt:
        die("\nProgram interrupted! Exiting...")
    except Exception, e:
        logger.exception(e)
        die('FATAL ERROR: %s' % e)
