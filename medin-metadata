#!/usr/bin/env python2

# ensure we're using UTF-8
import sys
sys = reload(sys)
sys.setdefaultencoding('utf-8')

class Version(object):
    """Representation of program version information"""

    def __init__(self, major, minor, patch):
        self.major = major
        self.minor = minor
        self.patch = patch

    @classmethod
    def parse(cls, version_str):
        """Class method to parse a version string into a Version object"""
        import re

        m = re.search('(\d+)\.(\d+)\.(\d+)', version_str)
        if not m:
            raise ValueError('The version string could not be parsed')

        return cls(*[int(g) for g in m.groups()])

    def __cmp__(self, other):
        """Compare one version with another"""
        
        res = cmp(self.major, other.major)
        if res != 0: return res
        res = cmp(self.minor, other.minor)
        if res != 0: return res
        return cmp(self.patch, other.patch)

    def __str__(self):
        return '%d.%d.%d' % (self.major, self.minor, self.patch)

def warn(msg):
    """Output a message to standard error"""

    sys.stderr.write("%s\n" % msg)
    try:
        log(msg)
    except NameError:
        pass                    # for when the medin module can't be imported
    
def die(msg):
    """End the program with a message"""

    warn(msg)
    sys.exit(1)

def get_version(config_cmd):
    """Try and retrieve a program version"""

    import subprocess

    try:
        p = subprocess.Popen([config_cmd, '--version'], stdout=subprocess.PIPE, stderr=subprocess.PIPE);
    except OSError, e:
        die("There was an error retrieving version information using %s: %s" % (config_cmd, str(e)))
    out, err = p.communicate()
    if err and p.returncode != 0:
        raise die("There was an error retrieving version information using %s: %s" % (config_cmd, err))

    try:
        return Version.parse(out)
    except ValueError:
        die('The version of %s could not be determined' % config_cmd)

def check_environment():
    """Check whether the system supports the program requirements"""

    # ensure we've got libxml2 and libxslt on the system
    try:
        import libxml2
    except ImportError:
        die('The libxml2 python module needs to be installed. See http://xmlsoft.org/python.html')

    try:
        import libxslt
    except ImportError:
        die('The libxslt python module needs to be installed. See http://xmlsoft.org/XSLT/python.html')

    # check we've got minimum python support
    if Version(*sys.version_info[:3]) < Version(2, 6, 0):
        die('Python 2.6 or greater is required')

    # check we've got minimum libxml2 support
    version_cur = get_version('xml2-config')
    version_min = Version(2, 6, 26)
    if version_cur < version_min:
        die('Your version of libxml2 is %s, it needs to be at least %s' % (version_cur, version_min))

    # check we've got minimum libxslt support
    version_cur = get_version('xslt-config')
    version_min = Version(1, 1, 17)
    if version_cur < version_min:
        die('Your version of libxslt is %s, it needs to be at least %s' % (version_cur, version_min))

class Output(object):

    def __init__(self, validate=False):
        self.validate = validate

    def processMetadata(self, metadata):
        """
        Process an individual metadata instance
        """
        from cStringIO import StringIO
        import libxml2
        from medin import log
        from medin.metadata import XMLBuilder
        from medin.validate import validate, ValidationError

        # transform the metadata to XML
        builder = XMLBuilder(metadata)
        doc = builder.build()

        # try and validate the xml
        if self.validate:
            log('Performing validation')
            try:
                validate(doc)
            except ValidationError, e:
                warn('The document is not valid: %s' % e.args[0])
                return None
            except Exception, e:
                die('FATAL ERROR: ' + str(e))
            else:
                log("The document is valid")

        # output the document
        f = StringIO()
        buf = libxml2.createOutputBuffer(f, 'utf-8')
        doc.saveFormatFileTo(buf, 'utf-8', True)
        doc.freeDoc()                       # clean up

        return f.getvalue().strip()

    def write(self, fh, iter_metadata):
        for metadata in iter_metadata:
            xml = self.processMetadata(metadata)
            if not xml:
                continue
            fh.write(xml)
            fh.write("\n")

class MIMEOutput(Output):

    def __init__(self, *args, **kwargs):
        from uuid import uuid4
        self.uid = uuid4().hex  # get an unique identifer

        super(MIMEOutput, self).__init__(*args, **kwargs)

    def write(self, fh, iter_metadata):
        from medin import __version__
        fh.write("""MIME-Version: 1.0
Content-Type: multipart/mixed; charset=UTF-8; boundary="%s"

MEDIN XML Metadata created by MEDIN Metadata Generator version %s\n""" % (self.uid, str(__version__)))

        for metadata in iter_metadata:
            xml = self.processMetadata(metadata)
            if not xml:
                continue
            filename = metadata.unique_id.id + '.xml'
            fh.write("""--%s
Content-Type: text/xml; charset=UTF-8;
Content-Disposition: inline; filename="%s";

""" % (self.uid, filename))
            fh.write(xml)
            fh.write("\n")

        fh.write("--%s--\n" % self.uid)  # the final boundary

def main():
    from optparse import OptionParser

    # try and load the medin modules
    try:
        import medin
        from medin import log, __version__
        import medin.provider
        import medin.vocabulary
    except ImportError:
        die('The medin module could not be found. Please ensure it is in your python module search path.')
    
    # parse out the command options
    usage = """usage: %prog [OPTION]... [PROVIDER] [CONNSTRING]

    Extract Metadata from a data provider database as MEDIN XML.

    PROVIDER is the provider name e.g. 'example' and CONNSTRING is the
    connection parameter string for accessing the database."""

    parser = OptionParser(usage=usage, version="%%prog %s" % str(__version__))

    # add the command line options
    parser.add_option("-u", '--update-vocab', action="store_true",
                      help="Update the locally stored vocabularies from the internet")
    parser.add_option("-d", '--debug', action="store_true",
                      help="Enable debugging output")
    parser.add_option("-i", '--metadata-id', action="append",
                      help="Output a specific metadata ID. This option can be specified multiple times")
    parser.add_option("-n", '--no-mime', action="store_true",
                      help="Do not encapsulate the XML output in MIME format")
    parser.add_option("-v", '--validate', action="store_true",
                      help="""Enable validation of output XML. A three step validation is performed:
1. Validate against the ISO TC 211 schema.
2. Validate against the ISO TS 19139 A1 Constraints.
3. Validate against the Medin Metadata Profile.
Any XML document passing these tests complies with the Medin Metadata
requirements.""")

    (options, args) = parser.parse_args()
    try:
        provider_name, connstr = args
    except ValueError:
        parser.error("incorrect number of arguments")

    check_environment()

    # turn on debugging
    if options.debug:
        medin.DEBUG = True

    # try and load the provider plugin
    log('Attempting to load provider %s' % provider_name)
    import imp
    try:
        provider_module = imp.load_module(provider_name, *imp.find_module(provider_name, medin.provider.__path__))
    except ImportError:
        die('The provider is not supported: %s' % provider_name)

    # start a vocabulary session
    vocabs = medin.vocabulary.Session()

    # update the vocabularies
    if options.update_vocab:
        log("Setting up vocabularies")
        vocabs.create()    # clear and create the schema and hard-coded data
        log("Updating vocabularies from online sources")
        vocabs.update()    # update the online vocabs

    # retrieve the metadata
    provider = provider_module.Session(connstr, vocabs)
    if options.metadata_id:
        ids = set(options.metadata_id)

        def metadata_generator():
            for metadata_id in ids:
                # get a specific metadata id
                log('Getting metadata id %s' % metadata_id)
                metadata = provider.getMetadataById(metadata_id)
                if not metadata:
                    die('A metadata entry with the following id does not exist: %s' % metadata_id)
                yield metadata
    else:
        log('Retrieving all metadata entries')

        def metadata_generator():
            for metadata in provider:
                yield metadata

    # output the metadata entries
    if options.no_mime:
        cls = Output
    else:
        cls = MIMEOutput

    output = cls(options.validate)
    output.write(sys.stdout, metadata_generator())

if __name__ == '__main__':
    try:
        main()
    except IOError, e:
        if e.errno == 32:
            pass                # it's a broken pipe
        else:
            raise
